<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pypsa-China-ElecTRADE-Draworld, 2026 Version</title>

    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px auto;
            max-width: 1600px;
            background-color: #fcfcfc;
        }

        h1 { margin-bottom: 5px; font-weight: 600; }
        .subtitle { margin-bottom: 20px; color: #666; font-size: 14px; }

        /* Status Bar Style */
        .status-bar {
            background: #f8f9fa;
            border-left: 4px solid #2166ac;
            padding: 12px 20px;
            margin-bottom: 25px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            border: 1px solid #e9ecef;
        }

        .time-chip {
            font-weight: 700;
            color: #b2182b;
            background: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        h2 { margin-top: 40px; color: #333; }

        /* Container Styles */
        #priceMap, #provinceCurve {
            height: 650px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
            position: relative;
        }

        #socChart {
            height: 600px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
            margin-top: 20px;
        }

        #error { color:red; margin-top:10px; font-weight: bold; }

        .map-credit {
            position:absolute;
            bottom:8px;
            right:10px;
            font-size:11px;
            background:rgba(255,255,255,0.85);
            padding:6px 8px;
            border-radius:6px;
            line-height:1.4;
            box-shadow:0 0 4px rgba(0,0,0,0.15);
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div class="status-bar">
        <span>
            <strong style="color: #2166ac;">System Status:</strong> 
            Automated 33-node Dispatch | 
            <span id="data-status" style="color: #666;">Syncing data...</span>
        </span>
        <div id="beijing-clock" class="time-chip">Loading Time...</div>
    </div>

    <h1>China ElecTRADE — Daily Results (t+1) </h1>
    <div class="subtitle">
        Rolling 48h dispatch | 33-node zonal pricing | Automated publication
    </div>

    <div style="display:flex; gap:30px;">
        <div style="flex:1;">
            <h2>Province-Node Price Dynamics (24h Avg)</h2>
            <div id="priceMap"></div>
        </div>
        <div style="flex:1;">
            <h2 id="curveTitle">Price Profile, Day-ahead</h2>
            <div id="provinceCurve"></div>
        </div>
    </div>

    <h2> Storage Status of Charge (SOC) by Tomorrow </h2>
    <div id="socChart"></div>

    <div id="error"></div>

<script>
let mapInstance;
let hoverPopup;

/* ---------- Helper: Centroid to fix duplicate circles in MultiPoint ---------- */
function getCentroid(feature) {
    const geom = feature.geometry;
    let coords = [];
    
    if (geom.type === 'Point') {
        coords = [geom.coordinates];
    } else if (geom.type === 'MultiPoint') {
        coords = geom.coordinates;
    } else if (geom.type === 'Polygon') {
        coords = geom.coordinates[0];
    } else if (geom.type === 'MultiPolygon') {
        coords = geom.coordinates[0][0];
    }

    if (!coords || coords.length === 0) return [104, 35];

    let lon = 0, lat = 0;
    coords.forEach(c => {
        lon += c[0];
        lat += c[1];
    });
    return [lon / coords.length, lat / coords.length];
}

/* ---------- CSV Loader (BOM SAFE) ---------- */
async function loadCSV(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error("File not found: " + url);
    const text = await res.text();
    const rows = text.trim().split("\n");
    // Handle UTF-8 BOM
    const headers = rows[0].replace(/^\uFEFF/, "").split(",");
    
    return rows.slice(1).map(row => {
        const values = row.split(",");
        const obj = {};
        headers.forEach((h, i) => {
            obj[h.trim()] = values[i] ? values[i].trim() : null;
        });
        return obj;
    });
}

/* ---------- MAIN APP LOGIC ---------- */
async function loadApp() {
    try {
        // Fetch Index
        const config = await fetch("out/index.json").then(r => r.json());

        // Update Metadata in Status Bar
        if (config.last_update && config.delivery_date) {
            const statusEl = document.getElementById('data-status');
            statusEl.innerHTML = `Latest Results: <b style="color:#b2182b;">${config.delivery_date}</b> ` +
                                 `<span style="font-size:12px; color:#888;">(Cleared at: ${config.last_update})</span>`;
        }

        // Process Price Files
        const priceFiles = config.price_files.slice().sort((a, b) => b.localeCompare(a));
        const latestPriceFile = priceFiles[0];
        const priceData = await loadCSV("out/prices/" + latestPriceFile);

        const columns = Object.keys(priceData[0]);
        const provinces = columns.filter(c => 
            c !== "snapshot" && 
            !c.toLowerCase().includes("__battery") && 
            !c.toLowerCase().includes("__pumped")
        );

        const timestamps = priceData.map(d => d.snapshot);

        // Calculate Averages for Map
        let avgPrice = {};
        provinces.forEach(zone => {
            const vals = priceData.map(d => Number(d[zone])).filter(v => !isNaN(v));
            avgPrice[zone] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
        });

        // Initialize Map
        initMap(avgPrice, priceData, timestamps);

        // Handle Storage SOC
        const socData = await loadCSV("out/" + config.soc_file);
        Plotly.newPlot("socChart", [{
            x: socData.map(d => d.name),
            y: socData.map(d => Number(Object.values(d)[1])),
            type: "bar",
            marker: { color: '#2166ac' }
        }], {
            title: `Storage SOC State (${latestPriceFile.replace('.csv','')})`,
            xaxis: { title: "Storage Unit", tickfont: { size: 10 } },
            yaxis: { title: "Energy (MWh)" },
            margin: { b: 150, t: 50 }
        });

    } catch (err) {
        const errorEl = document.getElementById("error");
        if (errorEl) errorEl.innerText = "Application Error: " + err.message;
        console.error(err);
    }
}

/* ---------- MAP COMPONENT ---------- */
function initMap(avgPrice, data, timestamps) {
    mapInstance = new maplibregl.Map({
        container: 'priceMap',
        style: "https://demotiles.maplibre.org/style.json",
        center: [105, 37],
        zoom: 3.8
    });

    mapInstance.on('load', async () => {
        const rawGeo = await fetch("geo/china_33nodes.geojson").then(r => r.json());

        // Source 1: Original Polygons for the Light Borders
        mapInstance.addSource('provinces', { type: 'geojson', data: rawGeo });

        // Source 2: Processed Points for Circles
        const processedFeatures = rawGeo.features.map(f => {
            const geoName = f.properties.name.trim();
            const price = avgPrice[geoName] || 0;
            return {
                type: "Feature",
                properties: { ...f.properties, price: isFinite(price) ? price : 0 },
                geometry: { type: "Point", coordinates: getCentroid(f) }
            };
        });
        mapInstance.addSource('nodes', { 
            type: 'geojson', 
            data: { type: "FeatureCollection", features: processedFeatures } 
        });

        // Layer 1: Subtle Province Borders (The specific fix you requested)
        mapInstance.addLayer({
            'id': 'province-borders',
            'type': 'line',
            'source': 'provinces',
            'paint': {
                'line-color': '#cccccc',
                'line-opacity': 0.35,
                'line-width': 0.7
            }
        });

        // Layer 2: Circles (Color by Price)
        mapInstance.addLayer({
            id: 'node-circle',
            type: 'circle',
            source: 'nodes',
            paint: {
                'circle-radius': 15,
                'circle-color': [
                    'interpolate', ['linear'], ['get', 'price'],
                    0, '#2166ac', 150, '#f7f7f7', 300, '#b2182b'
                ],
                'circle-stroke-width': 2,
                'circle-stroke-color': '#fff'
            }
        });

        // Layer 3: Labels
        mapInstance.addLayer({
            id: 'node-label',
            type: 'symbol',
            source: 'nodes',
            layout: {
                'text-field': ['get', 'name'],
                'text-size': 11,
                'text-offset': [0, 2],
                'text-anchor': 'top'
            },
            paint: { 'text-halo-color': '#fff', 'text-halo-width': 1.5 }
        });

        // Add Watermark
        const credit = document.createElement("div");
        credit.className = "map-credit";
        credit.innerHTML = `ElecTRADE @ Draworld, Beijing<br>Optimization @ PyPSA | Map @ MapLibre`;
        document.getElementById("priceMap").appendChild(credit);

        // Interaction Logic
        hoverPopup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });

        mapInstance.on('mousemove', 'node-circle', e => {
            const p = e.features[0].properties;
            mapInstance.getCanvas().style.cursor = 'pointer';
            hoverPopup.setLngLat(e.lngLat)
                .setHTML(`<b>${p.name}</b><br>Avg: ${p.price.toFixed(0)} RMB/MWh`)
                .addTo(mapInstance);
        });

        mapInstance.on('mouseleave', 'node-circle', () => {
            mapInstance.getCanvas().style.cursor = '';
            hoverPopup.remove();
        });

        mapInstance.on('click', 'node-circle', e => {
            showProvinceCurve(e.features[0].properties.name, data, timestamps);
        });

        // Default: Show Guangdong Curve
        const guangdongNode = processedFeatures.find(f => f.properties.name === "Guangdong") || processedFeatures[0];
        showProvinceCurve(guangdongNode.properties.name, data, timestamps);
    });
}

/* ---------- CHART COMPONENT ---------- */
function showProvinceCurve(zone, data, timestamps) {
    Plotly.newPlot("provinceCurve", [{
        x: timestamps,
        y: data.map(d => Number(d[zone])),
        mode: "lines+markers",
        name: zone,
        line: { color: '#b2182b', width: 2 },
        marker: { size: 4 }
    }], {
        title: `Day-ahead Price Profile: ${zone}`,
        xaxis: { title: "Time" },
        yaxis: { title: "Price (RMB/MWh)" },
        margin: { t: 50, b: 50, l: 60, r: 30 }
    });
    document.getElementById("curveTitle").innerText = "Hourly Price — " + zone;
}

/* ---------- REAL-TIME CLOCK ---------- */
function updateBeijingTime() {
    const options = { 
        timeZone: 'Asia/Shanghai', 
        hour: '2-digit', 
        minute: '2-digit', 
        month: '2-digit', 
        day: '2-digit', 
        year: 'numeric', 
        weekday: 'long',
        hour12: false 
    };
    const now = new Intl.DateTimeFormat('en-GB', options).format(new Date());
    document.getElementById('beijing-clock').innerText = `Beijing Time: ${now}`;
    setTimeout(updateBeijingTime, 60000);
}

// Kickoff
updateBeijingTime();
loadApp();
</script>

</body>
</html>