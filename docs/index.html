<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>China ElecTRADE Daily Market</title>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px auto;
        max-width: 1600px;
        background-color: #fcfcfc;
    }
    h2 { margin-top: 40px; color: #333; }
    #priceMap, #provinceCurve { height: 650px; background: white; border-radius: 8px; border: 1px solid #ddd; }
    #socChart { height: 600px; background: white; border-radius: 8px; border: 1px solid #ddd; margin-top: 20px; }
    #error { color:red; margin-top:10px; font-weight: bold; padding: 10px; background: #ffeeee; border-radius: 4px; display: none; }
</style>
</head>

<body>

<h1>China ElecTRADE — Daily Results</h1>

<div style="display:flex; gap:30px;">
    <div style="flex:1;">
        <h2>Provincial Price Distribution (24h Avg)</h2>
        <div id="priceMap"></div>
    </div>
    <div style="flex:1;">
        <h2 id="curveTitle">Hourly Price</h2>
        <div id="provinceCurve"></div>
    </div>
</div>

<h2>Final Storage SOC</h2>
<div id="socChart"></div>

<div id="error"></div>

<script>

let mapInstance;
let hoverPopup;

/* ---------- Helper: Centroid for MultiPoint to fix duplicate circles ---------- */
function getCentroid(feature) {
    const geom = feature.geometry;
    if (geom.type === 'Point') return geom.coordinates;
    
    let coords = [];
    if (geom.type === 'MultiPoint') coords = geom.coordinates;
    else if (geom.type === 'Polygon') coords = geom.coordinates[0];
    else if (geom.type === 'MultiPolygon') coords = geom.coordinates[0][0];

    if (coords.length === 0) return [104, 35]; // Fallback center

    let lon = 0, lat = 0;
    coords.forEach(c => { lon += c[0]; lat += c[1]; });
    return [lon / coords.length, lat / coords.length];
}

/* ---------- CSV Loader (BOM SAFE) ---------- */
async function loadCSV(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error("File not found: " + url);
    const text = await res.text();
    const rows = text.trim().split("\n");
    const headers = rows[0].replace(/^\uFEFF/, "").split(",");
    return rows.slice(1).map(row => {
        const values = row.split(",");
        return Object.fromEntries(headers.map((h,i) => [h.trim(), values[i]]));
    });
}

/* ---------- MAIN ---------- */
async function loadApp() {
    try {
        const config = await fetch("out/index.json").then(r => r.json());

        // Target Date Logic: Seek the absolute latest file in the list 
        // to ensure 02-21 is picked if it's the most recent data generated.
        const sortedFiles = config.price_files.sort().reverse();
        const targetFile = sortedFiles[0]; 
        
        console.log("Loading primary data file:", targetFile);

        const priceData = await loadCSV("out/prices/" + targetFile);
        const columns = Object.keys(priceData[0]);
        const provinces = columns.filter(c => c.trim() !== "snapshot" && !c.includes("__"));
        const timestamps = priceData.map(d => d.snapshot);

        let avgPrice = {};
        provinces.forEach(zone => {
            const vals = priceData.map(d => Number(d[zone])).filter(v => !isNaN(v));
            avgPrice[zone] = vals.length > 0 ? vals.reduce((a,b)=>a+b,0) / vals.length : 0;
        });

        initMap(avgPrice, priceData, timestamps);

        // Load SOC
        const socData = await loadCSV("out/" + config.soc_file);
        Plotly.newPlot("socChart", [{
            x: socData.map(d => d.name),
            y: socData.map(d => Number(Object.values(d)[1])),
            type: "bar",
            marker: { color: '#2166ac' }
        }], {
            title: `Final Storage SOC (${targetFile.replace('.csv','')})`,
            xaxis: { title: "Storage Unit" },
            yaxis: { title: "Energy (MWh)" }
        });

    } catch (err) {
        const errDiv = document.getElementById("error");
        errDiv.style.display = "block";
        errDiv.innerText = "Error: " + err.message;
        console.error(err);
    }
}

/* ---------- MAP ---------- */
function initMap(avgPrice, data, timestamps) {
    mapInstance = new maplibregl.Map({
        container: 'priceMap',
        style: "https://demotiles.maplibre.org/style.json",
        center: [105, 37],
        zoom: 3.8
    });

    mapInstance.on('load', async () => {
        const rawGeo = await fetch("geo/china_33nodes.geojson").then(r => r.json());

        // Process features to ensure exactly ONE point per province record
        const processedFeatures = rawGeo.features.map(f => {
            const geoName = f.properties.name.trim();
            // Try matching with price data
            const matchKey = Object.keys(avgPrice).find(k => k.trim() === geoName);
            const price = matchKey ? avgPrice[matchKey] : 0;
            
            return {
                type: "Feature",
                properties: { ...f.properties, price: isFinite(price) ? price : 0 },
                geometry: {
                    type: "Point",
                    coordinates: getCentroid(f)
                }
            };
        });

        const geo = { type: "FeatureCollection", features: processedFeatures };

        mapInstance.addSource('nodes', { type: 'geojson', data: geo });

        mapInstance.addLayer({
            id: 'node-circle',
            type: 'circle',
            source: 'nodes',
            paint: {
                'circle-radius': 15,
                'circle-color': [
                    'interpolate', ['linear'], ['get', 'price'],
                    0, '#2166ac', 150, '#f7f7f7', 300, '#b2182b'
                ],
                'circle-stroke-width': 2,
                'circle-stroke-color': '#fff'
            }
        });

        mapInstance.addLayer({
            id: 'node-label',
            type: 'symbol',
            source: 'nodes',
            layout: {
                'text-field': ['get', 'name'],
                'text-size': 11,
                'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                'text-radial-offset': 1.2
            },
            paint: {
                'text-halo-color': '#fff',
                'text-halo-width': 1.5
            }
        });

        hoverPopup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });

        mapInstance.on('mousemove', 'node-circle', e => {
            const p = e.features[0].properties;
            mapInstance.getCanvas().style.cursor = 'pointer';
            hoverPopup.setLngLat(e.lngLat)
                .setHTML(`<b>${p.name}</b><br>Avg: ${p.price.toFixed(2)} RMB/MWh`)
                .addTo(mapInstance);
        });

        mapInstance.on('mouseleave', 'node-circle', () => {
            mapInstance.getCanvas().style.cursor = '';
            hoverPopup.remove();
        });

        mapInstance.on('click', 'node-circle', e => {
            showProvinceCurve(e.features[0].properties.name, data, timestamps);
        });

        // Trigger initial curve for first feature
        if(geo.features.length > 0) showProvinceCurve(geo.features[0].properties.name, data, timestamps);
    });
}

function showProvinceCurve(zone, data, timestamps) {
    Plotly.newPlot("provinceCurve", [{
        x: timestamps,
        y: data.map(d => Number(d[zone])),
        mode: "lines+markers",
        name: zone,
        line: { color: '#b2182b', width: 2 },
        marker: { size: 4 }
    }], {
        title: `Hourly Price Profile: ${zone}`,
        xaxis: { title: "Time (Snapshot)" },
        yaxis: { title: "Price (RMB/MWh)" },
        margin: { t: 50, b: 50, l: 60, r: 30 }
    });
    document.getElementById("curveTitle").innerText = "Hourly Price — " + zone;
}

loadApp();
</script>

</body>
</html>